// Markov.coffee - Markov chains in CoffeeScript.
// github.com/SyntaxColoring/Markov-Word-Generator
//
// Released under the MIT license.
//
// Copyright (c) 2013 Max Marrone
//
// Permission is hereby granted, free of charge, to any person obtaining a copy of
// this software and associated documentation files (the "Software"), to deal in
// the Software without restriction, including without limitation the rights to
// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
// the Software, and to permit persons to whom the Software is furnished to do so,
// subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
// FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
// COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
// IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
// CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

// Modifications 2017-02-21
//  - Converted to TypeScript
//  - Modified to use seedable random number generator for reproducible results
import {RandomSeed} from "random-seed";

export class Markov {
	private sequences: Array<string>;
	private n: number;
	private maxLength: number;
	private random: RandomSeed;

	// Creates a new Markov chain from the given array of sequences
	// (to collectively use as a corpus) and value for n (to use as the Markov order).
	// sequences may be empty. n must be an integer no lower than 0.
	// Feel free to directly access and modify an object's .sequences and .n.
	constructor(sequences: Array<string> = [], n: number = 2, maxLength: number = 20) {
		this.sequences = sequences;
		this.n = n;
		this.maxLength = maxLength;
		this.random = require("random-seed").create(sequences.join())
	}

	// Generates a new pseudo random sequence generated by the Markov chain and
	// returns it as an array.  Its length will be truncated to @maxLength if necessary.
	public generate() {
		let nextElement;
		let result: Array<string> = [];
		let currentState = () => { // Returns at most the last @ elements of result.
			return result.slice(Math.max(0, result.length - this.n), result.length);
		};
		let continuation = () => this.continue(currentState());
		while ((result.length < this.maxLength) && ((nextElement = continuation()) != null)) {
			result.push(nextElement);
		}
		return result;
	}

	// Returns in an array the n-grams that went into making the Markov chain
	// Note that the size of the n-grams will always be one greater than the
	// Markov order - if a Markov chain was created with n=2, this method
	// will return an array of 3-grams.
	private ngrams() {
		let ngramsFromSequence = function (sequence: string, n: number) {
			if ((n < 1) || (n > sequence.length)) {
				return [];
			} else {
				return Markov.range(0, sequence.length - n, true).map((i) => sequence.slice(i, i + n));
			}
		};
		return this.sequences.reduce(((a, b) => a.concat(ngramsFromSequence(b, this.n + 1))), []);
	}

	// Builds a probability tree and returns the node of the given sequence, or
	// the root node if no sequence is specified.  Returns null if the given
	// sequence is not represented in the tree.
	//
	// Each node has a "count", "frequency" and "continuations" property.
	// For example:
	//   node = myMarkov.tree("abc")
	//   c = node.continuations["d"].count
	//   f = node.continuations["d"].frequency
	// c would be the number of times that "d" came after "abc" in the original corpus.
	// f would be the probability that the letter to follow "abc" is "d."
	private tree(sequence: Array<string> = []) {
		let ngrams = this.ngrams();
		let root = {continuations: {}, count: ngrams.length, frequency: 1.0};

		// Build the tree and supply each node with its count property.
		ngrams.forEach((ngram) => {
			let node: any = root;
			return ngram.split("").map((element: any) => {
				if (node.continuations[element] == null) {
					node.continuations[element] = {
						continuations: {},
						count: 0
					};
				}
				node = node.continuations[element];
				return node.count++;
			});
		});

		// Recursively descend through the tree we just built and give each node its
		// frequency property.
		let normalize: any = function (node: any) {
			return (() => {
				let result: any = [];
				for (let childName in node.continuations) {
					let child = node.continuations[childName];
					child.frequency = child.count / node.count;
					result.push(normalize(child));
				}
				return result;
			})();
		};

		normalize(root);

		let reduce = function (node: any, element: any) {
			if (node != null) {
				return node.continuations[element] != null ? node.continuations[element] : null;
			} else {
				return null;
			}
		};
		return sequence.reduce(reduce, root);
	}

	// Uses the Markov chain to pick the next element to come after sequence.
	// Returns null if there are no possible continuations.
	private continue(sequence: Array<string>) {
		let node = this.tree(sequence);
		if (node != null) {
			let target = this.random.random();
			let sum = 0;
			for (let continuationName in node.continuations) {
				let continuationNode = node.continuations[continuationName];
				sum += continuationNode.frequency;
				if (sum >= target) {
					return continuationName;
				}
			}
		}
		return null; // Either the node was null or it had no continuations.
	}

	private static range(left: number, right: number, inclusive: boolean) {
		let range = [];
		let ascending = left < right;
		let end = !inclusive ? right : ascending ? right + 1 : right - 1;
		for (let i = left; ascending ? i < end : i > end; ascending ? i++ : i--) {
			range.push(i);
		}
		return range;
	}
}
